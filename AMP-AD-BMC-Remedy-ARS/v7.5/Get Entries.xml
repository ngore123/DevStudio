<process draft="false" dev-studio-version="20.02.01">
  <process-def name=":AMP-AD-BMC-Remedy-ARS:v7.5:Get Entries">
    <parameters>
      <input global="false" required="false">
        <description>The name of the adapter to be used by this process, as configured in Grid Manager. If the adapter name is not provided, then "ARSAdapter" will be used.</description>
        <from>adapter name</from>
        <to>adapter name</to>
      </input>
      <input global="false" required="true">
        <description>The name of the schema with which to interact</description>
        <from>schema name</from>
        <to>schema name</to>
      </input>
      <input global="false" required="true">
        <description>an xml document with the following structure.

&lt;fields&gt;
&lt;field&gt;first field&lt;/field&gt;
&lt;field&gt;second field&lt;/field&gt;
          as required...
&lt;/fields&gt;</description>
        <from>requested fields</from>
        <to>requested fields</to>
      </input>
      <input global="false" required="false">
        <description>The query statement to be used to determine the records to be selected. This may be a complex condition that includes the key and value variables and operators.

For example, a match condition may be:

'key1' &gt; value1 and 'key2' &lt; value2

The default if nothing is provided is 'key1 = 'value1'</description>
        <from>match condition</from>
        <to>match condition</to>
      </input>
      <input global="false" required="false">
        <description>Identifies a field to be evaluated according to the match condition specified.</description>
        <from>key1</from>
        <to>key1</to>
      </input>
      <input global="false" required="false">
        <description>Identifies the value that must be present in the key1 field for an entry to be selected, based on the match condition specified.</description>
        <from>value1</from>
        <to>value1</to>
      </input>
      <input global="false" required="false">
        <description>Identifies an additional field to be evaluated according to the match condition specified.

Note: This input will not be used unless 'key2' is specifically included in the match condition input.</description>
        <from>key2</from>
        <to>key2</to>
      </input>
      <input global="false" required="false">
        <description>Identifies the value that must be present in the key2 field for an entry to be selected, based on the match condition specified.

Note: This input will not be used unless 'value2' is specifically included in the match condition input.</description>
        <from>value2</from>
        <to>value2</to>
      </input>
      <input global="false" required="false">
        <description>This parameter is used to specify whether attachment needs to be downloded with details or 
only with details in response.
If value set to true then attachment are downloaded on configured detination location (configurable through adapter configuration)on disk. if false then only attachment details are added in response.

Valid values:
1. true
2. false</description>
        <from>download attachments</from>
        <to>download attachments</to>
      </input>
      <input global="false" required="false">
        <description>This parameter is used to specify the attachment to be sent in adapter response 
itself in Base 64 encoded string and set this string in &lt;attachment-data&gt; element in response if valuse is set to true else &lt;attachment-data&gt; is not added in response. Default value is false.
Note: if &lt;retrieve-attachment-in-response&gt; is set to true then &lt;download-attachments&gt; parameter value is not considered.
Only attachment details are shown in response if "retrieve-attachment-in-response" and "download-attachments"parameter values are set to false.
Valid values:
1. true
2. false</description>
        <from>retrieve attachment in response</from>
        <to>retrieve attachment in response</to>
      </input>
      <input global="false" required="false">
        <description>This parameter is used to limit the number of fetch records that match the query, this feature is useful when developer wants to process the records in batch when there are huge number of records that match the query qualification. E.g. If there are 3000 records that match the query, one can limit (let say 500) the records per request that number can be specified in this parameter to fetch the records with limit. This feature is only useful when the fetched records with limit is processed and updated with another value so that duplicate records are not fetched in next iteration of request with same query.

Input data type: Positive Integer 
Valid value: greater than or equal to 0 (0 = all matching records)
</description>
        <from>maximum records to retrieve</from>
        <to>maximum records to retrieve</to>
      </input>
      <input global="false" required="false">
        <description>XML input parameter to specify the sorting criteria (ascending/descending) on records to be retrieved in adapter response 

Sample Input XML to specify sort criteria list

&lt;sort-field-list&gt;
   &lt;field&gt;
             &lt;name-or-id&gt;&lt;/name-or-id&gt;
             &lt;order&gt;&lt;/order&gt;
    &lt;/field&gt;
    &lt;field&gt;
             &lt;name-or-id&gt;&lt;/name-or-id&gt;
             &lt;order&gt;&lt;/order&gt;
     &lt;/field&gt;
&lt;/sort-field-list&gt; 

XML Input Parameters element Description:


sort-field-list: Root element of XML input to specify the sort criteria list 
field:Each field's child elements contains the remedy form field and order info to perform the sorting on records 
name-or-id : The Remedy Schema field Name or ID are specified on which Sorting to be performed 
order: Specify sorting order of provided field specified in name-or-id element 
Valid Values:
1 or ASC : Results is sorted in Ascending Order of given field specified in corresponding name-or-id element
2 or DESC : Results is sorted in Descending Order of given field specified in corresponding name-or-id element 
Default  sorting order (i.e. ASC) is Ascending if order element is either not specified or contain invalid value

Example:

&lt;sort-field-list&gt;
		&lt;field&gt;
			&lt;name-or-id&gt;FirstName&lt;/name-or-id&gt;
			&lt;order&gt;DESC&lt;/order&gt;
		&lt;/field&gt;
		&lt;field&gt;
			&lt;name-or-id&gt;536870914&lt;/name-or-id&gt; 
			&lt;order&gt;1&lt;/order&gt;
		&lt;/field&gt;
	&lt;/sort-field-list&gt;
</description>
        <from>sort list</from>
        <to>sort list</to>
      </input>
      <output global="false" required="true">
        <to>adapter response</to>
        <from>adapter response</from>
      </output>
    </parameters>
    <access />
    <sequence>
      <switch>
        <meta>
          <documentation />
          <run-mode-handling>
            <run-mode>OCP</run-mode>
            <allow-step-into>true</allow-step-into>
          </run-mode-handling>
          <checkpoint>false</checkpoint>
        </meta>
        <execute-all-applicable-cases>false</execute-all-applicable-cases>
        <default>
          <sequence>
            <switch>
              <meta>
                <documentation />
                <run-mode-handling>
                  <run-mode>OCP</run-mode>
                  <allow-step-into>true</allow-step-into>
                </run-mode-handling>
                <checkpoint>false</checkpoint>
              </meta>
              <execute-all-applicable-cases>false</execute-all-applicable-cases>
              <default>
                <sequence>
                  <switch>
                    <meta>
                      <documentation />
                      <run-mode-handling>
                        <run-mode>OCP</run-mode>
                        <allow-step-into>true</allow-step-into>
                      </run-mode-handling>
                      <checkpoint>false</checkpoint>
                    </meta>
                    <execute-all-applicable-cases>false</execute-all-applicable-cases>
                    <default>
                      <sequence>
                        <assign>
                          <assignment>
                            <document>
                              <input>
                                <from>match condition</from>
                              </input>
                            </document>
                            <result>
                              <output>
                                <to>match condition</to>
                              </output>
                            </result>
                            <xslt-stylesheet>
                              <stylesheet-replacement-tokens />
                              <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:escapeUtils="org.apache.commons.lang.StringEscapeUtils" version="1.0">
  <xsl:output indent="no" />
  <xsl:template match="/">
    <value>
      <xsl:value-of select="escapeUtils:escapeXml(.)" disable-output-escaping="no" />
    </value>
  </xsl:template>
</xsl:stylesheet>]]></stylesheet>
                            </xslt-stylesheet>
                          </assignment>
                          <meta>
                            <documentation />
                            <checkpoint>false</checkpoint>
                          </meta>
                          <location>:switch[1]:sequence[1]:switch[1]:sequence[1]:switch[1]:sequence[1]:assign[1]</location>
                        </assign>
                      </sequence>
                    </default>
                    <case>
                      <condition>
                        <document>
                          <input>
                            <from>match condition</from>
                          </input>
                        </document>
                        <xpath-expression>
                          <xpath-replacement-tokens />
                          <xpath><![CDATA[contains(., "&amp;")]]></xpath>
                        </xpath-expression>
                      </condition>
                      <sequence />
                    </case>
                    <location>:switch[1]:sequence[1]:switch[1]:sequence[1]:switch[1]</location>
                  </switch>
                </sequence>
              </default>
              <case>
                <condition>
                  <document>
                    <input>
                      <from>match condition</from>
                    </input>
                  </document>
                  <xpath-expression>
                    <xpath-replacement-tokens />
                    <xpath><![CDATA[string-length()=0]]></xpath>
                  </xpath-expression>
                </condition>
                <sequence>
                  <switch>
                    <meta>
                      <documentation />
                      <run-mode-handling>
                        <run-mode>OCP</run-mode>
                        <allow-step-into>true</allow-step-into>
                      </run-mode-handling>
                      <checkpoint>false</checkpoint>
                    </meta>
                    <execute-all-applicable-cases>false</execute-all-applicable-cases>
                    <default>
                      <sequence>
                        <assign>
                          <assignment>
                            <output>
                              <to>match condition</to>
                              <value>'key1'="value1"</value>
                            </output>
                          </assignment>
                          <meta>
                            <documentation />
                            <checkpoint>false</checkpoint>
                          </meta>
                          <location>:switch[1]:sequence[1]:switch[1]:sequence[2]:switch[1]:sequence[1]:assign[1]</location>
                        </assign>
                      </sequence>
                    </default>
                    <case>
                      <condition>
                        <document>
                          <input>
                            <from>key1</from>
                          </input>
                        </document>
                        <xpath-expression>
                          <xpath-replacement-tokens />
                          <xpath><![CDATA[string-length(.)>0]]></xpath>
                        </xpath-expression>
                      </condition>
                      <sequence>
                        <assign>
                          <assignment>
                            <input>
                              <concat>
                                <input>
                                  <value>'</value>
                                </input>
                                <input required="false">
                                  <from>key1</from>
                                </input>
                                <input>
                                  <value>'="</value>
                                </input>
                                <input required="false">
                                  <from>value1</from>
                                </input>
                                <input>
                                  <value>"</value>
                                </input>
                              </concat>
                            </input>
                            <output>
                              <to>match condition</to>
                            </output>
                          </assignment>
                          <meta>
                            <documentation />
                            <checkpoint>false</checkpoint>
                          </meta>
                          <location>:switch[1]:sequence[1]:switch[1]:sequence[2]:switch[1]:sequence[2]:assign[1]</location>
                        </assign>
                      </sequence>
                    </case>
                    <case>
                      <condition>
                        <document>
                          <input>
                            <from>key2</from>
                          </input>
                        </document>
                        <xpath-expression>
                          <xpath-replacement-tokens />
                          <xpath><![CDATA[string-length(.)>0]]></xpath>
                        </xpath-expression>
                      </condition>
                      <sequence>
                        <assign>
                          <assignment>
                            <input>
                              <concat>
                                <input>
                                  <value>'</value>
                                </input>
                                <input required="false">
                                  <from>key2</from>
                                </input>
                                <input>
                                  <value>'="</value>
                                </input>
                                <input required="false">
                                  <from>value2</from>
                                </input>
                                <input>
                                  <value>"</value>
                                </input>
                              </concat>
                            </input>
                            <output>
                              <to>match condition</to>
                            </output>
                          </assignment>
                          <meta>
                            <documentation />
                            <checkpoint>false</checkpoint>
                          </meta>
                          <location>:switch[1]:sequence[1]:switch[1]:sequence[2]:switch[1]:sequence[3]:assign[1]</location>
                        </assign>
                      </sequence>
                    </case>
                    <location>:switch[1]:sequence[1]:switch[1]:sequence[2]:switch[1]</location>
                  </switch>
                </sequence>
              </case>
              <location>:switch[1]:sequence[1]:switch[1]</location>
            </switch>
            <assign>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'&lt;'"/>
        <xsl:with-param name="to" select="'&amp;lt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'AMP_XSLT_VALUE_OF_TAG'"/>
        <xsl:with-param name="to" select="'value-of'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <meta>
                <documentation />
                <checkpoint>false</checkpoint>
              </meta>
              <location>:switch[1]:sequence[1]:assign[1]</location>
            </assign>
            <call-process>
              <process-name>:AMP-AD-BMC-Remedy-ARS:Utilities:Set Default Adapter Name</process-name>
              <parameters>
                <input>
                  <from>adapter name</from>
                  <to>adapter name</to>
                </input>
                <output>
                  <from>adapter name</from>
                  <to>adapter name</to>
                </output>
              </parameters>
              <meta>
                <documentation />
                <run-mode-handling>
                  <run-mode>OCP</run-mode>
                  <allow-step-into>false</allow-step-into>
                </run-mode-handling>
                <checkpoint>false</checkpoint>
              </meta>
              <location>:switch[1]:sequence[1]:call-process[1]</location>
            </call-process>
            <assign>
              <assignment>
                <document>
                  <input>
                    <from>requested fields</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>adapter request</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens>
                    <replacement-token name="schema name">
                      <input global="false">
                        <from>schema name</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="key1">
                      <input global="false">
                        <from>key1</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="value1">
                      <input global="false">
                        <from>value1</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="match condition">
                      <input global="false">
                        <from>match condition</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="value2">
                      <input global="false">
                        <from>value2</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="key2">
                      <input global="false">
                        <from>key2</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="download attachments">
                      <input global="false">
                        <from>download attachments</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="retrieve attachment in response">
                      <input global="false">
                        <from>retrieve attachment in response</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="max records to retrieve">
                      <input global="false">
                        <from>maximum records to retrieve</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="sort list">
                      <input global="false">
                        <from>sort list</from>
                      </input>
                    </replacement-token>
                  </stylesheet-replacement-tokens>
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
  <xsl:output indent="no" />
  <xsl:variable name="key1">${key1}</xsl:variable>
  <xsl:variable name="key2">${key2}</xsl:variable>
  <xsl:variable name="value1">${value1}</xsl:variable>
  <xsl:variable name="value2">${value2}</xsl:variable>
  <xsl:template match="/">
    <request-data>
      <remedy-action>
        <xsl:if test="string-length('${download attachments}')!=0">
          <download-attachments>
            <xsl:text disable-output-escaping="no">${download attachments}</xsl:text>
          </download-attachments>
        </xsl:if>
        <xsl:if test="string-length('${retrieve attachment in response}')!=0">
          <retrieve-attachment-in-response>
            <xsl:text disable-output-escaping="no">${retrieve attachment in response}</xsl:text>
          </retrieve-attachment-in-response>
        </xsl:if>
        <schema>${schema name}</schema>
        <xsl:if test="string-length('$[max records to retrieve]')!=0">
          <max-retrieve>
            <xsl:text disable-output-escaping="no">$[max records to retrieve]</xsl:text>
          </max-retrieve>
        </xsl:if>
        <query>${match condition}</query>
        <xsl:copy-of select="." />
        ${sort list}
      </remedy-action>
    </request-data>
  </xsl:template>
</xsl:stylesheet>]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <meta>
                <documentation />
                <checkpoint>false</checkpoint>
              </meta>
              <location>:switch[1]:sequence[1]:assign[2]</location>
            </assign>
          </sequence>
        </default>
        <case>
          <condition>
            <document>
              <input>
                <from>key1</from>
              </input>
            </document>
            <xpath-expression>
              <xpath-replacement-tokens>
                <replacement-token name="value1">
                  <input global="false">
                    <from>value1</from>
                  </input>
                </replacement-token>
                <replacement-token name="key2">
                  <input global="false">
                    <from>key2</from>
                  </input>
                </replacement-token>
                <replacement-token name="value2">
                  <input global="false">
                    <from>value2</from>
                  </input>
                </replacement-token>
              </xpath-replacement-tokens>
              <xpath><![CDATA[(string-length(.)>=1 or string-length('${value1}')>=1) or (string-length('${key2}')>=1 or string-length('${value2}')>=1)]]></xpath>
            </xpath-expression>
          </condition>
          <sequence>
            <switch>
              <meta>
                <documentation />
                <run-mode-handling>
                  <run-mode>OCP</run-mode>
                  <allow-step-into>true</allow-step-into>
                </run-mode-handling>
                <checkpoint>false</checkpoint>
              </meta>
              <execute-all-applicable-cases>false</execute-all-applicable-cases>
              <default>
                <sequence>
                  <assign>
                    <assignment>
                      <document>
                        <input>
                          <from>match condition</from>
                        </input>
                      </document>
                      <result>
                        <output>
                          <to>match condition</to>
                        </output>
                      </result>
                      <xslt-stylesheet>
                        <stylesheet-replacement-tokens />
                        <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:escapeUtils="org.apache.commons.lang.StringEscapeUtils" version="1.0">
  <xsl:output indent="no" />
  <xsl:template match="/">
    <value>
      <xsl:value-of select="escapeUtils:escapeXml(.)" disable-output-escaping="no" />
    </value>
  </xsl:template>
</xsl:stylesheet>]]></stylesheet>
                      </xslt-stylesheet>
                    </assignment>
                    <meta>
                      <documentation />
                      <checkpoint>false</checkpoint>
                    </meta>
                    <location>:switch[1]:sequence[2]:switch[1]:sequence[1]:assign[1]</location>
                  </assign>
                </sequence>
              </default>
              <case>
                <condition>
                  <document>
                    <input>
                      <from>match condition</from>
                    </input>
                  </document>
                  <xpath-expression>
                    <xpath-replacement-tokens />
                    <xpath><![CDATA[string-length()=0]]></xpath>
                  </xpath-expression>
                </condition>
                <sequence>
                  <assign>
                    <assignment>
                      <output>
                        <to>match condition</to>
                        <value>'key1'="value1"</value>
                      </output>
                    </assignment>
                    <meta>
                      <documentation />
                      <checkpoint>false</checkpoint>
                    </meta>
                    <location>:switch[1]:sequence[2]:switch[1]:sequence[2]:assign[1]</location>
                  </assign>
                </sequence>
              </case>
              <location>:switch[1]:sequence[2]:switch[1]</location>
            </switch>
            <assign>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'&lt;'"/>
        <xsl:with-param name="to" select="'&amp;lt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'key1'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$key1&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'key2'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$key2&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'key3'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$key3&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'key4'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$key4&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'key5'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$key5&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'key6'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$key6&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'key7'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$key7&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'key8'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$key8&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'value1'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$value1&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'value2'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$value2&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'value3'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$value3&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'value4'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$value4&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'value5'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$value5&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'value6'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$value6&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'value7'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$value7&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'value8'"/>
        <xsl:with-param name="to" select="'&lt;xsl:AMP_XSLT_VALUE_OF_TAG select=&quot;$value8&quot;/&gt;'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <assignment>
                <document>
                  <input>
                    <from>match condition</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>match condition</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens />
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">

<xsl:template match="/">
   <value>
   <xsl:call-template name="replace-string">
        <xsl:with-param name="text"
             select="."/>
        <xsl:with-param name="from" select="'AMP_XSLT_VALUE_OF_TAG'"/>
        <xsl:with-param name="to" select="'value-of'" />
    </xsl:call-template>
    </value>
</xsl:template>

<!-- reusable replace-string function -->
<xsl:template name="replace-string">
    <xsl:param name="text"/>
    <xsl:param name="from"/>
    <xsl:param name="to"/>

    <xsl:choose>
      <xsl:when test="contains($text, $from)">

        <xsl:variable name="before" select="substring-before($text, $from)"/>
        <xsl:variable name="after" select="substring-after($text, $from)"/>
        <xsl:variable name="prefix" select="concat($before, $to)"/>

        <xsl:value-of select="$before"/>
        <xsl:value-of select="$to"/>
        <xsl:call-template name="replace-string">
          <xsl:with-param name="text" select="$after"/>
          <xsl:with-param name="from" select="$from"/>
          <xsl:with-param name="to" select="$to"/>
        </xsl:call-template>
      </xsl:when>
      <xsl:otherwise>
        <xsl:value-of select="$text"/>
      </xsl:otherwise>
    </xsl:choose>
</xsl:template>

</xsl:stylesheet>
]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <meta>
                <documentation />
                <checkpoint>false</checkpoint>
              </meta>
              <location>:switch[1]:sequence[2]:assign[1]</location>
            </assign>
            <call-process>
              <process-name>:AMP-AD-BMC-Remedy-ARS:Utilities:Set Default Adapter Name</process-name>
              <parameters>
                <input>
                  <from>adapter name</from>
                  <to>adapter name</to>
                </input>
                <output>
                  <from>adapter name</from>
                  <to>adapter name</to>
                </output>
              </parameters>
              <meta>
                <documentation />
                <run-mode-handling>
                  <run-mode>OCP</run-mode>
                  <allow-step-into>false</allow-step-into>
                </run-mode-handling>
                <checkpoint>false</checkpoint>
              </meta>
              <location>:switch[1]:sequence[2]:call-process[1]</location>
            </call-process>
            <assign>
              <assignment>
                <document>
                  <input>
                    <from>requested fields</from>
                  </input>
                </document>
                <result>
                  <output>
                    <to>adapter request</to>
                  </output>
                </result>
                <xslt-stylesheet>
                  <stylesheet-replacement-tokens>
                    <replacement-token name="schema name">
                      <input global="false">
                        <from>schema name</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="key1">
                      <input global="false">
                        <from>key1</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="value1">
                      <input global="false">
                        <from>value1</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="match condition">
                      <input global="false">
                        <from>match condition</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="value2">
                      <input global="false">
                        <from>value2</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="key2">
                      <input global="false">
                        <from>key2</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="download attachments">
                      <input global="false">
                        <from>download attachments</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="retrieve attachment in response">
                      <input global="false">
                        <from>retrieve attachment in response</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="max records to retrieve">
                      <input global="false">
                        <from>maximum records to retrieve</from>
                      </input>
                    </replacement-token>
                    <replacement-token name="sort list">
                      <input global="false">
                        <from>sort list</from>
                      </input>
                    </replacement-token>
                  </stylesheet-replacement-tokens>
                  <stylesheet><![CDATA[<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0">
  <xsl:output indent="yes" />
  <xsl:variable name="key1">${key1}</xsl:variable>
  <xsl:variable name="key2">${key2}</xsl:variable>
  <xsl:variable name="value1">${value1}</xsl:variable>
  <xsl:variable name="value2">${value2}</xsl:variable>
  <xsl:template match="/">
    <request-data>
      <remedy-action>
        <xsl:if test="string-length('${download attachments}')!=0">
          <download-attachments>
            <xsl:text disable-output-escaping="no">${download attachments}</xsl:text>
          </download-attachments>
        </xsl:if>
        <xsl:if test="string-length('${retrieve attachment in response}')!=0">
          <retrieve-attachment-in-response>
            <xsl:text disable-output-escaping="no">${retrieve attachment in response}</xsl:text>
          </retrieve-attachment-in-response>
        </xsl:if>
        <schema>${schema name}</schema>
        <xsl:if test="string-length('$[max records to retrieve]')!=0">
          <max-retrieve>
            <xsl:text disable-output-escaping="no">$[max records to retrieve]</xsl:text>
          </max-retrieve>
        </xsl:if>
        <query>${match condition}</query>
        <xsl:copy-of select="." />
        ${sort list}
      </remedy-action>
    </request-data>
  </xsl:template>
</xsl:stylesheet>]]></stylesheet>
                </xslt-stylesheet>
              </assignment>
              <meta>
                <documentation />
                <checkpoint>false</checkpoint>
              </meta>
              <location>:switch[1]:sequence[2]:assign[2]</location>
            </assign>
          </sequence>
        </case>
        <location>:switch[1]</location>
      </switch>
      <call-adapter>
        <use-system-adapter>false</use-system-adapter>
        <parameters>
          <input global="false">
            <from>adapter name</from>
          </input>
          <input>
            <value>
              <adapter-request>
                <peer-location>
                  <location>any</location>
                </peer-location>
                <request-action>query</request-action>
              </adapter-request>
            </value>
          </input>
          <input global="false">
            <from>adapter request</from>
          </input>
          <input global="false">
            <from>adapter request</from>
          </input>
          <output global="false">
            <to>adapter response</to>
          </output>
        </parameters>
        <meta>
          <documentation />
          <checkpoint>false</checkpoint>
        </meta>
        <before-execution>
          <log>
            <level>debug</level>
            <parameters>
              <input>
                <value>Adapter request</value>
              </input>
              <input>
                <from>adapter request</from>
              </input>
            </parameters>
          </log>
        </before-execution>
        <after-execution>
          <log>
            <level>debug</level>
            <parameters>
              <input>
                <value>Adapter response</value>
              </input>
              <input>
                <from>adapter response</from>
              </input>
            </parameters>
          </log>
        </after-execution>
        <location>:call-adapter[1]</location>
      </call-adapter>
    </sequence>
    <meta>
      <expose-to>
        <consumer>RULE</consumer>
        <consumer>SCHEDULE</consumer>
      </expose-to>
      <documentation>
        <description>Get Entries
    Gets one or more entries from a Remedy repository satisfying a specified condition.
 
</description>
        <version>1.0</version>
      </documentation>
      <logging-options>
        <is-enabled>false</is-enabled>
        <log-file-name></log-file-name>
      </logging-options>
      <peer-location>
        <location>any</location>
      </peer-location>
      <record-metrics>false</record-metrics>
      <process-id>694ef6ec-2a5a-4e30-ae3d-907328923cc7</process-id>
      <author>admin</author>
      <category></category>
      <status></status>
      <keywords></keywords>
      <systems></systems>
      <last-modified-by>aoadmin</last-modified-by>
      <last-modified>1676458361352</last-modified>
    </meta>
  </process-def>
</process>